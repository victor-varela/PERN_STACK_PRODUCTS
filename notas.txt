1.Backend (Node + Express)
Define las rutas REST (/api/users, /api/tasks, etc.).
Cada ruta maneja una acciÃ³n (leer, crear, actualizar o borrar datos).
Se conecta a PostgreSQL mediante un ORM (Sequelize, Prisma, etc.).

// ðŸ§© Â¿Por quÃ© usamos Express?

// âš™ï¸ Express es un framework para Node.js que nos facilita crear un servidor HTTP.
// Sirve como el "motor de comunicaciÃ³n" ðŸš¦ entre el frontend (React) y la base de datos (PostgreSQL).

// ðŸ§  Node.js por sÃ­ solo provee el entorno donde corre el cÃ³digo,
// pero Express agrega una capa mÃ¡s amigable para:
//  1ï¸âƒ£ Definir rutas REST (GET, POST, PUT, DELETE).
//  2ï¸âƒ£ Manejar peticiones y respuestas fÃ¡cilmente.
//  3ï¸âƒ£ Conectar la lÃ³gica del servidor con la base de datos.
//  4ï¸âƒ£ Organizar el cÃ³digo en mÃ³dulos claros y mantenibles.

// ðŸ“¦ Sin Express, podrÃ­amos hacer lo mismo usando el mÃ³dulo nativo 'http' de Node.js,
// pero serÃ­a mucho mÃ¡s manual. Ejemplo:

/*
import http from 'http'

const server = http.createServer((req, res) => {
  if (req.url === '/' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' })
    res.end(JSON.stringify({ message: 'Hola desde Node puro ðŸ‘‹' }))
  } else {
    res.writeHead(404, { 'Content-Type': 'application/json' })
    res.end(JSON.stringify({ error: 'Ruta no encontrada' }))
  }
})

server.listen(4000, () => {
  console.log('Servidor corriendo en http://localhost:4000')
})
*/

// ðŸ˜® Como ves, sin Express tenemos que manejar manualmente:
//   - Las cabeceras de respuesta (headers).
//   - Los cÃ³digos de estado HTTP.
//   - El enrutamiento (quÃ© hacer segÃºn la URL y el mÃ©todo).

// ðŸš€ En cambio, con Express basta con escribir:
//
/*
import express from 'express'
const server = express()

server.get('/', (req, res) => {
  res.json({ message: 'Hola desde Express ðŸ‘‹' })
})

server.listen(4000, () => console.log('Servidor Express en http://localhost:4000'))
*/
// Mucho mÃ¡s limpio, legible y fÃ¡cil de escalar. ðŸ˜Ž


2.Base de datos (PostgreSQL)
Almacena los datos reales (usuarios, productos, etc.).
El ORM traduce tus objetos JS a consultas SQL para leer o escribir aquÃ­.

3.Frontend (React)
Consume esas rutas con fetch o axios.
Muestra los datos al usuario y envÃ­a cambios (por ejemplo, al enviar un formulario).

// âš™ï¸ CONFIGURACIÃ“N INICIAL DEL PROYECTO REST API CON TYPESCRIPT Y NODE
// --------------------------------------------------------------------

// 1ï¸âƒ£ CREACIÃ“N DEL PROYECTO BASE
// - AcciÃ³n: Crear la carpeta `rest_api_ts_server` y ejecutar `npm init`.
// - Por quÃ©: Inicializa un nuevo proyecto Node, generando `package.json`
//   donde se registran dependencias y scripts.
// - Luego: Instalar Express â†’ `npm install express` para manejar rutas y peticiones HTTP.
//   (Es el equivalente al â€œBig Bangâ€ de Node, como `npm create vite@latest` lo es para React).

// --------------------------------------------------------------------

// 2ï¸âƒ£ ARCHIVOS PRINCIPALES
// - AcciÃ³n: Crear `index.ts` (punto de entrada) y `server.ts` (configuraciÃ³n del servidor).
// - Por quÃ©: Separar el inicio de la app de su configuraciÃ³n hace el proyecto
//   mÃ¡s modular, escalable y fÃ¡cil de mantener.

// --------------------------------------------------------------------

// 3ï¸âƒ£ SOPORTE PARA TYPESCRIPT
// - AcciÃ³n: Instalar dependencias de desarrollo:
//     npm i -D typescript ts-node
// - Por quÃ©: Node solo entiende JavaScript; TypeScript necesita un traductor (`tsc`)
//   y un ejecutor (`ts-node`) para poder correr el cÃ³digo .ts.
// - Extra: Crear un archivo `tsconfig.json` vacÃ­o para que Node reconozca archivos .ts. Luego se completara la configuraciÃ³n de ese archivo.
// - EjecuciÃ³n manual del servidor:
//     npx ts-node src/index.ts

// --------------------------------------------------------------------

// 4ï¸âƒ£ AUTOMATIZAR EL REINICIO DEL SERVIDOR
// - AcciÃ³n: Instalar `nodemon` y agregar un script en package.json:
//     "scripts": { "dev": "nodemon --exec ts-node src/index.ts" }
// - Por quÃ©: Evita tener que reiniciar el servidor manualmente tras cada cambio.
// - Resultado: Correr `npm run dev` mantiene el servidor activo y actualizando en tiempo real.

// --------------------------------------------------------------------

// 5ï¸âƒ£ COMPILACIÃ“N TYPESCRIPT â†’ JAVASCRIPT
// - AcciÃ³n: Ejecutar `npx tsc src/index.ts`.
// - Por quÃ©: Compila archivos .ts a .js para que Node pueda ejecutarlos.
// - Nota: Eliminar los .js generados en /src para no mezclar archivos de desarrollo
//   con los de producciÃ³n (el cÃ³digo compilado irÃ¡ a /dist). 

// --------------------------------------------------------------------

// 6ï¸âƒ£ CONFIGURACIÃ“N DEL COMPILADOR (tsconfig.json)
// - AcciÃ³n: Configurar reglas para la compilaciÃ³n:
//     {
//       "compilerOptions": {
//         "outDir": "./dist",        // Carpeta para cÃ³digo compilado
//         "rootDir": "./src",        // Carpeta de cÃ³digo fuente
//         "lib": ["ESNext"],         // Funcionalidades modernas de JS
//         "strict": false,           // Menos restricciones en tipado
//         "sourceMap": true,         // Permite depurar .ts desde .js
//         "esModuleInterop": true,   // Soporte para imports comunes
//         "declaration": true        // Genera archivos .d.ts (tipos)
//       },
//       "include": ["src/**/*.ts"]
//     }
// - Por quÃ©:
//   - `/src` â†’ cÃ³digo fuente en desarrollo.
//   - `/dist` â†’ cÃ³digo compilado para producciÃ³n.
//   - Facilita depuraciÃ³n (sourceMap), compatibilidad (esModuleInterop) y organizaciÃ³n general.
//   - Ejecutar npx tsc y ahi va a crear la carpeta dist.

// --------------------------------------------------------------------

// ðŸ’¡ En resumen:
//   npm init  â†’ Crea el universo del proyecto Node.
//   Express   â†’ Le da forma al backend (maneja rutas y peticiones).
//   TypeScriptâ†’ Traduce y tipa el lenguaje.
//   Nodemon   â†’ Mantiene el servidor vivo y actualizado.
//   tsc       â†’ Transforma el cÃ³digo .ts a .js para producciÃ³n.


âš™ï¸ CONFIGURACION DEL SERVIDOR:
- Se instala la dev dependency @types/express para que soporte Ts.
- Usamos ThunderClient o Postman para probar manualmente los endpoints de nuestra API (son simuladores de peticiones HTTP). Mientras no tenemos una UI en React. EL navegador solo tiene naves de tipo GET y POST (si enviamos un formulario-> <form action='/' method='POST'), solo lee informacion y envia. Postman hay que instalarlo y ThunderClient es una extension de VsCode. NOs quedamos con ThunderClient para este proyecto. Simplemente haces una request y se ve directamente la respuesta.
- En server.ts instaciamos express. const server= express().
- Definimos las rutas (routing). Al principio con server.get- server.post, etc pero luego usamos router de express y reemplazamos server por router. Ese router lo importamos en server.ts
- Separamos las rutas a su propio archivo. router.ts de esa manera resumimos en server.use('/', router) todas las rutas que router.ts tiene. el .use engloba todos los verbos HTTP.

âš™ï¸ CONFIGURACION DE LA BASE DE DATOS: (PostgreSQL)
- Usamos Render para alojar la API y DB en la nube. De esta manera sera accesible mas alla de mi local.--> En el panel de render hacemos NEW POSTGRESS y llenamos los datos (name) create Db--> nos da un connection string 'URL de conexion' para usar desde .env con OTRA dependencias: doteenv

- Usamos Sequelize (ORM) para traducir los objetos TypeScript a SQL. Ejecutamos los npm de la documentacion. npm install --save sequelize y npm install --save pg pg-hstore # Postgres. Mas adelante en el curso se instala npm i sequelize-typescript para tener soporte de Ts y se reemplaza la instancia de sequelize en db.ts --> import {Sequelize} from 'sequelize-typescript'

- Usamos Dbeaver para ver las tablas de la DB. En el icono de enchufe para arriba con un + dice PostgreSQL. Ahi llenamos los datos que nos da Render. (en el connection string tambien estan los datos. Host (es lo que esta despues de @ hasta .com- inicia con dpg) Database es lo que esta despues de .com/ Autenticacion dejar DatabaseNative. Password esta despues de : hasta @)- Le damos en probar conexion y va a aparecer un panel con nuestra DB. Ahi expandemos hasta ver los esquemas tablas, etc bieeennnnnn

- Agregamos Colors para los mensajes en la consola. Ayuda a distinguir la informacion. npm install color--> ve la documentacion. es colors.aparecen los colores... Luego, todos los mensajes por consola los podemos estilizar.

- Creamos el Modelo de Products. Esto es la tabla de productos. Esta tabla la hacemos con sequelize -ORM- es el traductor entre el codigo y PostgreSQL. Para ello creamos la carpeta models. Un modelo es un 'molde' es como debe ser la tabla. La tabla la crea sequelize traduciendo a SQL el codigo Ts. Para 'ver' la tabla se usa Dbeaver. El modelo esta SINCRONIZADO con las columnas de la DB. Por eso el db.sync() en server.ts



