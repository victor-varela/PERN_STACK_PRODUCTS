1.Backend (Node + Express)
Define las rutas REST (/api/users, /api/tasks, etc.).
Cada ruta maneja una acción (leer, crear, actualizar o borrar datos).
Se conecta a PostgreSQL mediante un ORM (Sequelize, Prisma, etc.).

// 🧩 ¿Por qué usamos Express?

// ⚙️ Express es un framework para Node.js que nos facilita crear un servidor HTTP.
// Sirve como el "motor de comunicación" 🚦 entre el frontend (React) y la base de datos (PostgreSQL).

// 🧠 Node.js por sí solo provee el entorno donde corre el código,
// pero Express agrega una capa más amigable para:
//  1️⃣ Definir rutas REST (GET, POST, PUT, DELETE).
//  2️⃣ Manejar peticiones y respuestas fácilmente.
//  3️⃣ Conectar la lógica del servidor con la base de datos.
//  4️⃣ Organizar el código en módulos claros y mantenibles.

// 📦 Sin Express, podríamos hacer lo mismo usando el módulo nativo 'http' de Node.js,
// pero sería mucho más manual. Ejemplo:

/*
import http from 'http'

const server = http.createServer((req, res) => {
  if (req.url === '/' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' })
    res.end(JSON.stringify({ message: 'Hola desde Node puro 👋' }))
  } else {
    res.writeHead(404, { 'Content-Type': 'application/json' })
    res.end(JSON.stringify({ error: 'Ruta no encontrada' }))
  }
})

server.listen(4000, () => {
  console.log('Servidor corriendo en http://localhost:4000')
})
*/

// 😮 Como ves, sin Express tenemos que manejar manualmente:
//   - Las cabeceras de respuesta (headers).
//   - Los códigos de estado HTTP.
//   - El enrutamiento (qué hacer según la URL y el método).

// 🚀 En cambio, con Express basta con escribir:
//
/*
import express from 'express'
const server = express()

server.get('/', (req, res) => {
  res.json({ message: 'Hola desde Express 👋' })
})

server.listen(4000, () => console.log('Servidor Express en http://localhost:4000'))
*/
// Mucho más limpio, legible y fácil de escalar. 😎


2.Base de datos (PostgreSQL)
Almacena los datos reales (usuarios, productos, etc.).
El ORM traduce tus objetos JS a consultas SQL para leer o escribir aquí.

3.Frontend (React)
Consume esas rutas con fetch o axios.
Muestra los datos al usuario y envía cambios (por ejemplo, al enviar un formulario).

// ⚙️ CONFIGURACIÓN INICIAL DEL PROYECTO REST API CON TYPESCRIPT Y NODE
// --------------------------------------------------------------------

// 1️⃣ CREACIÓN DEL PROYECTO BASE
// - Acción: Crear la carpeta `rest_api_ts_server` y ejecutar `npm init`.
// - Por qué: Inicializa un nuevo proyecto Node, generando `package.json`
//   donde se registran dependencias y scripts.
// - Luego: Instalar Express → `npm install express` para manejar rutas y peticiones HTTP.
//   (Es el equivalente al “Big Bang” de Node, como `npm create vite@latest` lo es para React).

// --------------------------------------------------------------------

// 2️⃣ ARCHIVOS PRINCIPALES
// - Acción: Crear `index.ts` (punto de entrada) y `server.ts` (configuración del servidor).
// - Por qué: Separar el inicio de la app de su configuración hace el proyecto
//   más modular, escalable y fácil de mantener.

// --------------------------------------------------------------------

// 3️⃣ SOPORTE PARA TYPESCRIPT
// - Acción: Instalar dependencias de desarrollo:
//     npm i -D typescript ts-node
// - Por qué: Node solo entiende JavaScript; TypeScript necesita un traductor (`tsc`)
//   y un ejecutor (`ts-node`) para poder correr el código .ts.
// - Extra: Crear un archivo `tsconfig.json` vacío para que Node reconozca archivos .ts. Luego se completara la configuración de ese archivo.
// - Ejecución manual del servidor:
//     npx ts-node src/index.ts

// --------------------------------------------------------------------

// 4️⃣ AUTOMATIZAR EL REINICIO DEL SERVIDOR
// - Acción: Instalar `nodemon` y agregar un script en package.json:
//     "scripts": { "dev": "nodemon --exec ts-node src/index.ts" }
// - Por qué: Evita tener que reiniciar el servidor manualmente tras cada cambio.
// - Resultado: Correr `npm run dev` mantiene el servidor activo y actualizando en tiempo real.

// --------------------------------------------------------------------

// 5️⃣ COMPILACIÓN TYPESCRIPT → JAVASCRIPT
// - Acción: Ejecutar `npx tsc src/index.ts`.
// - Por qué: Compila archivos .ts a .js para que Node pueda ejecutarlos.
// - Nota: Eliminar los .js generados en /src para no mezclar archivos de desarrollo
//   con los de producción (el código compilado irá a /dist). 

// --------------------------------------------------------------------

// 6️⃣ CONFIGURACIÓN DEL COMPILADOR (tsconfig.json)
// - Acción: Configurar reglas para la compilación:
//     {
//       "compilerOptions": {
//         "outDir": "./dist",        // Carpeta para código compilado
//         "rootDir": "./src",        // Carpeta de código fuente
//         "lib": ["ESNext"],         // Funcionalidades modernas de JS
//         "strict": false,           // Menos restricciones en tipado
//         "sourceMap": true,         // Permite depurar .ts desde .js
//         "esModuleInterop": true,   // Soporte para imports comunes
//         "declaration": true        // Genera archivos .d.ts (tipos)
//       },
//       "include": ["src/**/*.ts"]
//     }
// - Por qué:
//   - `/src` → código fuente en desarrollo.
//   - `/dist` → código compilado para producción.
//   - Facilita depuración (sourceMap), compatibilidad (esModuleInterop) y organización general.
//   - Ejecutar npx tsc y ahi va a crear la carpeta dist.

// --------------------------------------------------------------------

// 💡 En resumen:
//   npm init  → Crea el universo del proyecto Node.
//   Express   → Le da forma al backend (maneja rutas y peticiones).
//   TypeScript→ Traduce y tipa el lenguaje.
//   Nodemon   → Mantiene el servidor vivo y actualizado.
//   tsc       → Transforma el código .ts a .js para producción.


⚙️ CONFIGURACION DEL SERVIDOR:
- Se instala la dev dependency @types/express para que soporte Ts.
- Usamos ThunderClient o Postman para probar manualmente los endpoints de nuestra API (son simuladores de peticiones HTTP). Mientras no tenemos una UI en React. EL navegador solo tiene naves de tipo GET y POST (si enviamos un formulario-> <form action='/' method='POST'), solo lee informacion y envia. Postman hay que instalarlo y ThunderClient es una extension de VsCode. NOs quedamos con ThunderClient para este proyecto. Simplemente haces una request y se ve directamente la respuesta.
- En server.ts instaciamos express. const server= express().
- Definimos las rutas (routing). Al principio con server.get- server.post, etc pero luego usamos router de express y reemplazamos server por router. Ese router lo importamos en server.ts
- Separamos las rutas a su propio archivo. router.ts de esa manera resumimos en server.use('/', router) todas las rutas que router.ts tiene. el .use engloba todos los verbos HTTP.

⚙️ CONFIGURACION DE LA BASE DE DATOS: (PostgreSQL)
- Usamos Render para alojar la API y DB en la nube. De esta manera sera accesible mas alla de mi local.--> En el panel de render hacemos NEW POSTGRESS y llenamos los datos (name) create Db--> nos da un connection string 'URL de conexion' para usar desde .env con OTRA dependencias: doteenv

- Usamos Sequelize (ORM) para traducir los objetos TypeScript a SQL. Ejecutamos los npm de la documentacion. npm install --save sequelize y npm install --save pg pg-hstore # Postgres. Mas adelante en el curso se instala npm i sequelize-typescript para tener soporte de Ts y se reemplaza la instancia de sequelize en db.ts --> import {Sequelize} from 'sequelize-typescript'

- Usamos Dbeaver para ver las tablas de la DB. En el icono de enchufe para arriba con un + dice PostgreSQL. Ahi llenamos los datos que nos da Render. (en el connection string tambien estan los datos. Host (es lo que esta despues de @ hasta .com- inicia con dpg) Database es lo que esta despues de .com/ Autenticacion dejar DatabaseNative. Password esta despues de : hasta @)- Le damos en probar conexion y va a aparecer un panel con nuestra DB. Ahi expandemos hasta ver los esquemas tablas, etc bieeennnnnn

- Agregamos Colors para los mensajes en la consola. Ayuda a distinguir la informacion. npm install color--> ve la documentacion. es colors.aparecen los colores... Luego, todos los mensajes por consola los podemos estilizar.

- Creamos el Modelo de Products. Esto es la tabla de productos. Esta tabla la hacemos con sequelize -ORM- es el traductor entre el codigo y PostgreSQL. Para ello creamos la carpeta models. Un modelo es un 'molde' es como debe ser la tabla. La tabla la crea sequelize traduciendo a SQL el codigo Ts. Para 'ver' la tabla se usa Dbeaver. El modelo esta SINCRONIZADO con las columnas de la DB. Por eso el db.sync() en server.ts



