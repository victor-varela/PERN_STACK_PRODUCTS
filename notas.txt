1.Backend (Node + Express)
Define las rutas REST (/api/users, /api/tasks, etc.).
Cada ruta maneja una acci√≥n (leer, crear, actualizar o borrar datos).
Se conecta a PostgreSQL mediante un ORM (Sequelize, Prisma, etc.).

// üß© ¬øPor qu√© usamos Express?

// ‚öôÔ∏è Express es un framework para Node.js que nos facilita crear un servidor HTTP.
// Sirve como el "motor de comunicaci√≥n" üö¶ entre el frontend (React) y la base de datos (PostgreSQL).

// üß† Node.js por s√≠ solo provee el entorno donde corre el c√≥digo,
// pero Express agrega una capa m√°s amigable para:
//  1Ô∏è‚É£ Definir rutas REST (GET, POST, PUT, DELETE).
//  2Ô∏è‚É£ Manejar peticiones y respuestas f√°cilmente.
//  3Ô∏è‚É£ Conectar la l√≥gica del servidor con la base de datos.
//  4Ô∏è‚É£ Organizar el c√≥digo en m√≥dulos claros y mantenibles.

// üì¶ Sin Express, podr√≠amos hacer lo mismo usando el m√≥dulo nativo 'http' de Node.js,
// pero ser√≠a mucho m√°s manual. Ejemplo:

/*
import http from 'http'

const server = http.createServer((req, res) => {
  if (req.url === '/' && req.method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' })
    res.end(JSON.stringify({ message: 'Hola desde Node puro üëã' }))
  } else {
    res.writeHead(404, { 'Content-Type': 'application/json' })
    res.end(JSON.stringify({ error: 'Ruta no encontrada' }))
  }
})

server.listen(4000, () => {
  console.log('Servidor corriendo en http://localhost:4000')
})
*/

// üòÆ Como ves, sin Express tenemos que manejar manualmente:
//   - Las cabeceras de respuesta (headers).
//   - Los c√≥digos de estado HTTP.
//   - El enrutamiento (qu√© hacer seg√∫n la URL y el m√©todo).

// üöÄ En cambio, con Express basta con escribir:
//
/*
import express from 'express'
const server = express()

server.get('/', (req, res) => {
  res.json({ message: 'Hola desde Express üëã' })
})

server.listen(4000, () => console.log('Servidor Express en http://localhost:4000'))
*/
// Mucho m√°s limpio, legible y f√°cil de escalar. üòé


2.Base de datos (PostgreSQL)
Almacena los datos reales (usuarios, productos, etc.).
El ORM traduce tus objetos JS a consultas SQL para leer o escribir aqu√≠.

3.Frontend (React)
Consume esas rutas con fetch o axios.
Muestra los datos al usuario y env√≠a cambios (por ejemplo, al enviar un formulario).

// ‚öôÔ∏è CONFIGURACI√ìN INICIAL DEL PROYECTO REST API CON TYPESCRIPT Y NODE
// --------------------------------------------------------------------

// 1Ô∏è‚É£ CREACI√ìN DEL PROYECTO BASE
// - Acci√≥n: Crear la carpeta `rest_api_ts_server` y ejecutar `npm init`.
// - Por qu√©: Inicializa un nuevo proyecto Node, generando `package.json`
//   donde se registran dependencias y scripts.
// - Luego: Instalar Express ‚Üí `npm install express` para manejar rutas y peticiones HTTP.
//   (Es el equivalente al ‚ÄúBig Bang‚Äù de Node, como `npm create vite@latest` lo es para React).

// --------------------------------------------------------------------

// 2Ô∏è‚É£ ARCHIVOS PRINCIPALES
// - Acci√≥n: Crear `index.ts` (punto de entrada) y `server.ts` (configuraci√≥n del servidor).
// - Por qu√©: Separar el inicio de la app de su configuraci√≥n hace el proyecto
//   m√°s modular, escalable y f√°cil de mantener.

// --------------------------------------------------------------------

// 3Ô∏è‚É£ SOPORTE PARA TYPESCRIPT
// - Acci√≥n: Instalar dependencias de desarrollo:
//     npm i -D typescript ts-node
// - Por qu√©: Node solo entiende JavaScript; TypeScript necesita un traductor (`tsc`)
//   y un ejecutor (`ts-node`) para poder correr el c√≥digo .ts.
// - Extra: Crear un archivo `tsconfig.json` vac√≠o para que Node reconozca archivos .ts. Luego se completara la configuraci√≥n de ese archivo.
// - Ejecuci√≥n manual del servidor:
//     npx ts-node src/index.ts

// --------------------------------------------------------------------

// 4Ô∏è‚É£ AUTOMATIZAR EL REINICIO DEL SERVIDOR
// - Acci√≥n: Instalar `nodemon` y agregar un script en package.json:
//     "scripts": { "dev": "nodemon --exec ts-node src/index.ts" }
// - Por qu√©: Evita tener que reiniciar el servidor manualmente tras cada cambio.
// - Resultado: Correr `npm run dev` mantiene el servidor activo y actualizando en tiempo real.

// --------------------------------------------------------------------

// 5Ô∏è‚É£ COMPILACI√ìN TYPESCRIPT ‚Üí JAVASCRIPT
// - Acci√≥n: Ejecutar `npx tsc src/index.ts`.
// - Por qu√©: Compila archivos .ts a .js para que Node pueda ejecutarlos.
// - Nota: Eliminar los .js generados en /src para no mezclar archivos de desarrollo
//   con los de producci√≥n (el c√≥digo compilado ir√° a /dist). 

// --------------------------------------------------------------------

// 6Ô∏è‚É£ CONFIGURACI√ìN DEL COMPILADOR (tsconfig.json)
// - Acci√≥n: Configurar reglas para la compilaci√≥n:
//     {
//       "compilerOptions": {
//         "outDir": "./dist",        // Carpeta para c√≥digo compilado
//         "rootDir": "./src",        // Carpeta de c√≥digo fuente
//         "lib": ["ESNext"],         // Funcionalidades modernas de JS - ESNext = EmmaScript Next
                                                                          el mas reciente
//         "strict": false,           // Menos restricciones en tipado
//         "sourceMap": true,         // Permite depurar .ts desde .js
//         "esModuleInterop": true,   // Soporte para imports comunes
//         "declaration": true        // Genera archivos .d.ts (tipos)
//       },
//       "include": ["src/**/*.ts"]
//     }
// - Por qu√©:
//   - `/src` ‚Üí c√≥digo fuente en desarrollo.
//   - `/dist` ‚Üí c√≥digo compilado para producci√≥n.
//   - Facilita depuraci√≥n (sourceMap), compatibilidad (esModuleInterop) y organizaci√≥n general.
//   - Ejecutar npx tsc y ahi va a crear la carpeta dist.
//   - OJO A medida que se va construyendo el proyecto se van agregando configuraciones OJOc

// --------------------------------------------------------------------

// üí° En resumen:
//   npm init  ‚Üí Crea el universo del proyecto Node.
//   Express   ‚Üí Le da forma al backend (maneja rutas y peticiones).
//   TypeScript‚Üí Traduce y tipa el lenguaje.
//   Nodemon   ‚Üí Mantiene el servidor vivo y actualizado.
//   tsc       ‚Üí Transforma el c√≥digo .ts a .js para producci√≥n.


  ‚öôÔ∏è CONFIGURACION DEL SERVIDOR:
  - Se instala la dev dependency @types/express para que soporte Ts.
  - Usamos ThunderClient o Postman para probar manualmente los endpoints de nuestra API (son simuladores de peticiones HTTP). Mientras no tenemos una UI en React. EL navegador solo tiene naves de tipo GET y POST (si enviamos un formulario-> <form action='/' method='POST'), solo lee informacion y envia. Postman hay que instalarlo y ThunderClient es una extension de VsCode. NOs quedamos con ThunderClient para este proyecto. Simplemente haces una request y se ve directamente la respuesta.-- USAMOS POSTMAN- ThunderClient es de pago ahora.

  - En server.ts instaciamos express. const server= express().
  - Definimos las rutas (routing). Al principio con server.get- server.post, etc pero luego usamos router de express y reemplazamos server por router. Ese router lo importamos en server.ts
  - Separamos las rutas a su propio archivo. router.ts de esa manera resumimos en server.use('/', router) todas las rutas que router.ts tiene. el .use engloba todos los verbos HTTP.

  ‚öôÔ∏è CONFIGURACION DE LA BASE DE DATOS: (PostgreSQL)
  - Usamos Render para alojar la API y DB en la nube. De esta manera sera accesible mas alla de mi local.--> En el panel de render hacemos NEW POSTGRESS y llenamos los datos (name)--> create Db--> nos da un connection string 'URL de conexion' para usar desde .env con OTRA dependencia: doteenv

  - Creamos carpeta config y archivo db.ts.- Ahi establecemos conexion a traves de sequelize con Render

  - Usamos Sequelize (ORM) para traducir los objetos TypeScript a SQL. Ejecutamos los npm de la documentacion. npm install --save sequelize y npm install --save pg pg-hstore # Postgres. Mas adelante en el curso se instala npm i sequelize-typescript para tener soporte de Ts y se reemplaza la instancia de sequelize en db.ts --> import {Sequelize} from 'sequelize-typescript'

  - Usamos Dbeaver para ver las tablas de la DB. En el icono de enchufe para arriba con un + dice PostgreSQL. Ahi llenamos los datos que nos da Render. (en el connection string tambien estan los datos. Host (es lo que esta despues de @ hasta .com- inicia con dpg) Database es lo que esta despues de .com/ Autenticacion dejar DatabaseNative. Password esta despues de : hasta @)- Le damos en probar conexion y va a aparecer un panel con nuestra DB. Ahi expandemos hasta ver los esquemas tablas, etc bieeennnnnn

  - Agregamos Colors para los mensajes en la consola. Ayuda a distinguir la informacion. npm install color--> ve la documentacion. es colors.aparecen los colores... Luego, todos los mensajes por consola los podemos estilizar.

  - Creamos el Modelo de Products. Esto es la tabla de productos. Esta tabla la hacemos con sequelize -ORM- es el traductor entre el codigo y PostgreSQL. Para ello creamos la carpeta models. Un modelo es un 'molde' es como debe ser la tabla. La tabla la crea sequelize traduciendo a SQL el codigo Ts. Para 'ver' la tabla se usa Dbeaver. El modelo esta SINCRONIZADO con las columnas de la DB. Por eso el db.sync() en server.ts

  ‚öôÔ∏è CREANDO FUNCIONES PARA INTERACTUAR CON LA DB
  - Creamos la carpeta handlers --> product.ts : funciones que manejan el modelo Product. Ahi estaran las funciones que van a reemplazar (req, res) en router.ts
  - Para enviar datos al endpoints usamos POSTMAN.- Almacenamos las peticiones http en una nueva coleccion para mejor organizaci√≥n. -> en el panel Collection. Para enviar en postman es en "raw" - Json y escribes en json
  - Te das cuenta que la configuraci√≥n de tsconfig.json es vital para el proyecto, muchos errores que van apareciendo se deben a que hay que ir agregando "soporte".
  - Creamos la carpeta middelware en Src para separar validacion y dejar el handler limpio.



