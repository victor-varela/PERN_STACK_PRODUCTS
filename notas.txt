1.Backend (Node + Express)
Define las rutas REST (/api/users, /api/tasks, etc.).
Cada ruta maneja una acciÃ³n (leer, crear, actualizar o borrar datos).
Se conecta a PostgreSQL mediante un ORM (Sequelize, Prisma, etc.).

2.Base de datos (PostgreSQL)
Almacena los datos reales (usuarios, productos, etc.).
El ORM traduce tus objetos JS a consultas SQL para leer o escribir aquÃ­.

3.Frontend (React)
Consume esas rutas con fetch o axios.
Muestra los datos al usuario y envÃ­a cambios (por ejemplo, al enviar un formulario).

// âš™ï¸ CONFIGURACIÃ“N INICIAL DEL PROYECTO REST API CON TYPESCRIPT Y NODE
// --------------------------------------------------------------------

// 1ï¸âƒ£ CREACIÃ“N DEL PROYECTO BASE
// - AcciÃ³n: Crear la carpeta `rest_api_ts_server` y ejecutar `npm init`.
// - Por quÃ©: Inicializa un nuevo proyecto Node, generando `package.json`
//   donde se registran dependencias y scripts.
// - Luego: Instalar Express â†’ `npm install express` para manejar rutas y peticiones HTTP.
//   (Es el equivalente al â€œBig Bangâ€ de Node, como `npm create vite@latest` lo es para React).

// --------------------------------------------------------------------

// 2ï¸âƒ£ ARCHIVOS PRINCIPALES
// - AcciÃ³n: Crear `index.ts` (punto de entrada) y `server.ts` (configuraciÃ³n del servidor).
// - Por quÃ©: Separar el inicio de la app de su configuraciÃ³n hace el proyecto
//   mÃ¡s modular, escalable y fÃ¡cil de mantener.

// --------------------------------------------------------------------

// 3ï¸âƒ£ SOPORTE PARA TYPESCRIPT
// - AcciÃ³n: Instalar dependencias de desarrollo:
//     npm i -D typescript ts-node
// - Por quÃ©: Node solo entiende JavaScript; TypeScript necesita un traductor (`tsc`)
//   y un ejecutor (`ts-node`) para poder correr el cÃ³digo .ts.
// - Extra: Crear un archivo `tsconfig.json` vacÃ­o para que Node reconozca archivos .ts. Luego se completara la configuraciÃ³n de ese archivo.
// - EjecuciÃ³n manual del servidor:
//     npx ts-node src/index.ts

// --------------------------------------------------------------------

// 4ï¸âƒ£ AUTOMATIZAR EL REINICIO DEL SERVIDOR
// - AcciÃ³n: Instalar `nodemon` y agregar un script en package.json:
//     "scripts": { "dev": "nodemon --exec ts-node src/index.ts" }
// - Por quÃ©: Evita tener que reiniciar el servidor manualmente tras cada cambio.
// - Resultado: Correr `npm run dev` mantiene el servidor activo y actualizando en tiempo real.

// --------------------------------------------------------------------

// 5ï¸âƒ£ COMPILACIÃ“N TYPESCRIPT â†’ JAVASCRIPT
// - AcciÃ³n: Ejecutar `npx tsc src/index.ts`.
// - Por quÃ©: Compila archivos .ts a .js para que Node pueda ejecutarlos.
// - Nota: Eliminar los .js generados en /src para no mezclar archivos de desarrollo
//   con los de producciÃ³n (el cÃ³digo compilado irÃ¡ a /dist). 

// --------------------------------------------------------------------

// 6ï¸âƒ£ CONFIGURACIÃ“N DEL COMPILADOR (tsconfig.json)
// - AcciÃ³n: Configurar reglas para la compilaciÃ³n:
//     {
//       "compilerOptions": {
//         "outDir": "./dist",        // Carpeta para cÃ³digo compilado
//         "rootDir": "./src",        // Carpeta de cÃ³digo fuente
//         "lib": ["ESNext"],         // Funcionalidades modernas de JS
//         "strict": false,           // Menos restricciones en tipado
//         "sourceMap": true,         // Permite depurar .ts desde .js
//         "esModuleInterop": true,   // Soporte para imports comunes
//         "declaration": true        // Genera archivos .d.ts (tipos)
//       },
//       "include": ["src/**/*.ts"]
//     }
// - Por quÃ©:
//   - `/src` â†’ cÃ³digo fuente en desarrollo.
//   - `/dist` â†’ cÃ³digo compilado para producciÃ³n.
//   - Facilita depuraciÃ³n (sourceMap), compatibilidad (esModuleInterop) y organizaciÃ³n general.
//   - Ejecutar npx tsc y ahi va a crear la carpeta dist.

// --------------------------------------------------------------------

// ðŸ’¡ En resumen:
//   npm init  â†’ Crea el universo del proyecto Node.
//   Express   â†’ Le da forma al backend (maneja rutas y peticiones).
//   TypeScriptâ†’ Traduce y tipa el lenguaje.
//   Nodemon   â†’ Mantiene el servidor vivo y actualizado.
//   tsc       â†’ Transforma el cÃ³digo .ts a .js para producciÃ³n.


âš™ï¸ CONFIGURACION DEL SERVIDOR:
- Se instala la dev dependency @types/express para que soporte Ts.
- Usamos ThunderClient o Postman para probar manualmente los endpoints de nuestra API (son simuladores de peticiones HTTP). Mientras no tenemos una UI en React. EL navegador solo tiene naves de tipo GET y POST (si enviamos un formulario-> <form action='/' method='POST'), solo lee informacion y envia. Postman hay que instalarlo y ThunderClient es una extension de VsCode. NOs quedamos con ThunderClient para este proyecto. Simplemente haces una request y se ve directamente la respuesta.
- En server.ts instaciamos express. const server= express().
- Definimos las rutas (routing). Al principio con server.get- server.post, etc pero luego usamos router de express y reemplazamos server por router. Ese router lo importamos en server.ts
- Separamos las rutas a su propio archivo. router.ts de esa manera resumimos en server.use('/', router) todas las rutas que router.ts tiene. el .use engloba todos los verbos HTTP.

âš™ï¸ CONFIGURACION DE LA BASE DE DATOS: (PostgreSQL)
- Usamos Render para alojar la API y DB en la nube. De esta manera sera accesible mas alla de mi local.--> En el panel de render hacemos NEW POSTGRESS y llenamos los datos (name) create Db--> nos da un connection string 'URL de conexion' para usar desde .env con OTRA dependencias: doteenv
- Usamos Sequelize (ORM) para traducir los objetos TypeScript a SQL. Ejecutamos los npm de la documentacion. npm install --save sequelize y npm install --save pg pg-hstore # Postgres
- Usamos Dbeaver para ver las tablas de la DB. En el icono de enchufe para arriba con un + dice PostgreSQL. Ahi llenamos los datos que nos da Render. (en el connection string tambien estan los datos. Host (es lo que esta despues de @ hasta .com- inicia con dpg) Database es lo que esta despues de .com/ Autenticacion dejar DatabaseNative. Password esta despues de : hasta @)- Le damos en probar conexion y va a aparecer un panel con nuestra DB. Ahi expandemos hasta ver los esquemas tablas, etc bieeennnnnn

- Agregamos Colors para los mensajes en la consola. Ayuda a distinguir la informacion. npm install color--> ve la documentacion. es colors.aparecen los colores... Luego, todos los mensajes por consola los podemos estilizar.



