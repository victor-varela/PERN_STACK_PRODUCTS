1.Backend (Node + Express)
Define las rutas REST (/api/users, /api/tasks, etc.).
Cada ruta maneja una acción (leer, crear, actualizar o borrar datos).
Se conecta a PostgreSQL mediante un ORM (Sequelize, Prisma, etc.).

2.Base de datos (PostgreSQL)
Almacena los datos reales (usuarios, productos, etc.).
El ORM traduce tus objetos JS a consultas SQL para leer o escribir aquí.

3.Frontend (React)
Consume esas rutas con fetch o axios.
Muestra los datos al usuario y envía cambios (por ejemplo, al enviar un formulario).

// ⚙️ CONFIGURACIÓN INICIAL DEL PROYECTO REST API CON TYPESCRIPT Y NODE
// --------------------------------------------------------------------

// 1️⃣ CREACIÓN DEL PROYECTO BASE
// - Acción: Crear la carpeta `rest_api_ts_server` y ejecutar `npm init`.
// - Por qué: Inicializa un nuevo proyecto Node, generando `package.json`
//   donde se registran dependencias y scripts.
// - Luego: Instalar Express → `npm install express` para manejar rutas y peticiones HTTP.
//   (Es el equivalente al “Big Bang” de Node, como `npm create vite@latest` lo es para React).

// --------------------------------------------------------------------

// 2️⃣ ARCHIVOS PRINCIPALES
// - Acción: Crear `index.ts` (punto de entrada) y `server.ts` (configuración del servidor).
// - Por qué: Separar el inicio de la app de su configuración hace el proyecto
//   más modular, escalable y fácil de mantener.

// --------------------------------------------------------------------

// 3️⃣ SOPORTE PARA TYPESCRIPT
// - Acción: Instalar dependencias de desarrollo:
//     npm i -D typescript ts-node
// - Por qué: Node solo entiende JavaScript; TypeScript necesita un traductor (`tsc`)
//   y un ejecutor (`ts-node`) para poder correr el código .ts.
// - Extra: Crear un archivo `tsconfig.json` vacío para que Node reconozca archivos .ts.
// - Ejecución manual del servidor:
//     npx ts-node src/index.ts

// --------------------------------------------------------------------

// 4️⃣ AUTOMATIZAR EL REINICIO DEL SERVIDOR
// - Acción: Instalar `nodemon` y agregar un script en package.json:
//     "scripts": { "dev": "nodemon --exec ts-node src/index.ts" }
// - Por qué: Evita tener que reiniciar el servidor manualmente tras cada cambio.
// - Resultado: Correr `npm run dev` mantiene el servidor activo y actualizando en tiempo real.

// --------------------------------------------------------------------

// 5️⃣ COMPILACIÓN TYPESCRIPT → JAVASCRIPT
// - Acción: Ejecutar `npx tsc src/index.ts`.
// - Por qué: Compila archivos .ts a .js para que Node pueda ejecutarlos.
// - Nota: Eliminar los .js generados en /src para no mezclar archivos de desarrollo
//   con los de producción (el código compilado irá a /dist). 

// --------------------------------------------------------------------

// 6️⃣ CONFIGURACIÓN DEL COMPILADOR (tsconfig.json)
// - Acción: Configurar reglas para la compilación:
//     {
//       "compilerOptions": {
//         "outDir": "./dist",        // Carpeta para código compilado
//         "rootDir": "./src",        // Carpeta de código fuente
//         "lib": ["ESNext"],         // Funcionalidades modernas de JS
//         "strict": false,           // Menos restricciones en tipado
//         "sourceMap": true,         // Permite depurar .ts desde .js
//         "esModuleInterop": true,   // Soporte para imports comunes
//         "declaration": true        // Genera archivos .d.ts (tipos)
//       },
//       "include": ["src/**/*.ts"]
//     }
// - Por qué:
//   - `/src` → código fuente en desarrollo.
//   - `/dist` → código compilado para producción.
//   - Facilita depuración (sourceMap), compatibilidad (esModuleInterop) y organización general.
//   - Ejecutar npx tsc y ahi va a crear la carpeta dist.

// --------------------------------------------------------------------

// 💡 En resumen:
//   npm init  → Crea el universo del proyecto Node.
//   Express   → Le da forma al backend (maneja rutas y peticiones).
//   TypeScript→ Traduce y tipa el lenguaje.
//   Nodemon   → Mantiene el servidor vivo y actualizado.
//   tsc       → Transforma el código .ts a .js para producción.


⚙️ CONFIGURACION DEL SERVIDOR:
- Se instala la dev dependency @types/express para que soporte Ts.
- Usamos ThunderClient o Postman para probar manualmente los endpoints de nuestra API (son simuladores de peticiones HTTP). Mientras no tenemos una UI en React. EL navegador solo tiene naves de tipo GET y POST (si enviamos un formulario-> <form action='/' method='POST'), solo lee informacion y envia. Postman hay que instalarlo y ThunderClient es una extension de VsCode. NOs quedamos con ThunderClient para este proyecto. Simplemente haces una request y se ve directamente la respuesta.
- Separamos las rutas a su propio archivo. router.ts de esa manera resumimos en server.use('/', router) todas las rutas que router.ts tiene.



